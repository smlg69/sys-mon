// pages/CCTVSystemPage.tsx
import React, { useState, useEffect, useCallback, useRef, useMemo } from "react";
import {
  Box,
  Paper,
  Typography,
  Grid,
  Card,
  CardContent,
  Button,
  IconButton,
  Alert,
  CircularProgress,
  Chip,
  Avatar,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Fab,
  Switch,
  FormControlLabel,
  Tab,
  Tabs,
  Snackbar,
  CardHeader,
  Tooltip,
  FormControl,
  InputLabel,
  MenuItem,
  Select,
  SelectChangeEvent,
} from "@mui/material";
import {
  Videocam,
  Schema,
  Build,
  Schedule,
  Refresh,
  ShowChart,
  Settings,
  TrendingUp,
  TrendingDown,
  ArrowUpward,
  ArrowDownward,
  CheckCircle,
  Warning as WarningIcon,
  Error as ErrorIcon,
  History,
  Camera,
  Storage,
  Computer,
  Lan,
  Router,
  Build as BuildIcon,
  Visibility,
  Assignment,
} from "@mui/icons-material";
import { apiClient } from "../api/client";
import { ReportPagination } from "../components/reports/Pagination";
import { useAlert } from "../hooks/useAlert";

// –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã –¥–∞–Ω–Ω—ã—Ö
interface CCTVDevice {
  id: string;
  name: string;
  type: string;
  status: "normal" | "warning" | "critical";
  value: string;
  group?: string;
  deviceId?: string;
  deviceName?: string;
  location?: string;
  timestamp?: string;
  description?: string;
  param?: string;
  active?: boolean;
  ipAddress?: string;
  resolution?: string;
  fps?: number;
  storageUsage?: number;
  isOnline?: boolean;
  currentValue?: number; // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª–µ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
}

interface CCTVDataPoint {
  timestamp: string;
  value: number;
  node: string;
  param: string;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

interface CCTVMaintenanceTask {
  id: string;
  task: string;
  taskDate: string;
  action: string;
  type: string;
  device: string;
  user: string;
  realDate: string | null;
}

interface HTFResponseItem {
  vUpdateTime: string;
  vValue: Array<{
    [key: string]: string | number;
    volumeDate: string;
    id: string;
  }>;
}

interface TblValuesItem {
  param?: string;
  name?: string;
  id?: string;
  value?: string | number;
  data?: string | number;
  val?: string | number;
  timestamp?: string;
  time?: string;
  created_at?: string;
  unit?: string;
  [key: string]: any;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;
  return (
    <div role="tabpanel" hidden={value !== index} {...other}>
      {value === index && <Box sx={{ pt: 3 }}>{children}</Box>}
    </div>
  );
}

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const WS_URL = process.env.REACT_APP_WS_URL;
const VARIABLES = process.env.REACT_APP_VARIABLES;
const FUNCTIONS = process.env.REACT_APP_FUNCTIONS;

// –ö–æ–º–ø–æ–Ω–µ–Ω—Ç –≥—Ä–∞—Ñ–∏–∫–∞
const CCTVChart: React.FC<{
  data: CCTVDataPoint[];
  title: string;
  color?: string;
  unit?: string;
  isLoading?: boolean;
}> = React.memo(
  ({ data, title, color = "#1976d2", unit = "–µ–¥.", isLoading = false }) => {
    const canvasRef = useRef<HTMLCanvasElement>(null);
    const [stats, setStats] = useState({
      min: 0,
      max: 0,
      current: 0,
      avg: 0,
      trend: 0,
    });

    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ 50 —Ç–æ—á–∫–∞–º–∏ –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
    const limitedData = useMemo(() => {
      if (data.length <= 50) return data;
      return data.slice(-50);
    }, [data]);

    const drawChart = useCallback(() => {
      if (!canvasRef.current) return;

      const canvas = canvasRef.current;
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (limitedData.length === 0) {
        ctx.fillStyle = "#999";
        ctx.font = "14px Inter";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(
          "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è",
          canvas.width / 2,
          canvas.height / 2
        );
        return;
      }

      const values = limitedData.map((d) => d.value);
      const minVal = Math.min(...values);
      const maxVal = Math.max(...values);
      const currentVal = limitedData[limitedData.length - 1]?.value || 0;
      const avgVal = values.reduce((a, b) => a + b, 0) / values.length;
      const trend = limitedData.length > 1 ? currentVal - limitedData[0].value : 0;

      setStats({
        min: minVal,
        max: maxVal,
        current: currentVal,
        avg: avgVal,
        trend,
      });

      const padding = { top: 40, right: 30, bottom: 50, left: 60 };
      const chartWidth = canvas.width - padding.left - padding.right;
      const chartHeight = canvas.height - padding.top - padding.bottom;
      const valueRange = maxVal - minVal || 1;

      // –°–µ—Ç–∫–∞
      ctx.strokeStyle = "#e0e0e0";
      ctx.lineWidth = 1;

      for (let i = 0; i <= 5; i++) {
        const y = padding.top + (i * chartHeight) / 5;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(padding.left + chartWidth, y);
        ctx.stroke();
      }

      // –ì—Ä–∞—Ñ–∏–∫
      ctx.beginPath();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      limitedData.forEach((point, index) => {
        const x = padding.left + (index / Math.max(limitedData.length - 1, 1)) * chartWidth;
        const y = padding.top + chartHeight - ((point.value - minVal) / valueRange) * chartHeight;

        if (index === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      });
      ctx.stroke();

      // –¢–æ—á–∫–∏
      ctx.fillStyle = color;
      if (limitedData.length <= 20) {
        limitedData.forEach((point, index) => {
          const x = padding.left + (index / Math.max(limitedData.length - 1, 1)) * chartWidth;
          const y = padding.top + chartHeight - ((point.value - minVal) / valueRange) * chartHeight;

          ctx.beginPath();
          ctx.arc(x, y, 4, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      // –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞
      if (limitedData.length > 0) {
        const lastIndex = limitedData.length - 1;
        const x = padding.left + chartWidth;
        const y = padding.top + chartHeight - ((limitedData[lastIndex].value - minVal) / valueRange) * chartHeight;

        ctx.beginPath();
        ctx.arc(x, y, 6, 0, Math.PI * 2);
        ctx.fillStyle = "#ff4444";
        ctx.fill();

        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // –ü–æ–¥–ø–∏—Å–∏
      ctx.fillStyle = "#333";
      ctx.font = "bold 14px Inter";
      ctx.textAlign = "center";
      ctx.fillText(title, canvas.width / 2, padding.top - 15);

      ctx.font = "12px Inter";
      ctx.textAlign = "right";
      ctx.fillStyle = "#666";
      ctx.fillText(`${maxVal.toFixed(1)}${unit}`, padding.left - 10, padding.top + 5);
      ctx.fillText(`${minVal.toFixed(1)}${unit}`, padding.left - 10, padding.top + chartHeight);

    }, [limitedData, title, color, unit]);

    useEffect(() => {
      drawChart();
      const handleResize = () => drawChart();
      window.addEventListener("resize", handleResize);
      return () => window.removeEventListener("resize", handleResize);
    }, [drawChart]);

    return (
      <Box sx={{ width: "100%", height: "100%", position: "relative" }}>
        <canvas
          ref={canvasRef}
          width={800}
          height={300}
          style={{
            width: "100%",
            height: "100%",
            backgroundColor: "#f9f9f9",
            borderRadius: "4px",
          }}
        />

        {isLoading && (
          <Box sx={{
            position: "absolute",
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: "rgba(255, 255, 255, 0.7)",
          }}>
            <CircularProgress size={24} />
          </Box>
        )}

        <Box sx={{
          position: "absolute",
          bottom: 10,
          left: 10,
          display: "flex",
          gap: 1,
        }}>
          <Chip
            size="small"
            icon={<ArrowDownward />}
            label={`${stats.min.toFixed(1)}${unit}`}
            variant="outlined"
            sx={{ backgroundColor: "rgba(255,255,255,0.9)" }}
          />
          <Chip
            size="small"
            icon={stats.trend > 0 ? <TrendingUp /> : <TrendingDown />}
            label={`${stats.current.toFixed(1)}${unit}`}
            color={stats.trend > 0 ? "success" : stats.trend < 0 ? "error" : "default"}
            sx={{ backgroundColor: "rgba(255,255,255,0.9)" }}
          />
          <Chip
            size="small"
            icon={<ArrowUpward />}
            label={`${stats.max.toFixed(1)}${unit}`}
            variant="outlined"
            sx={{ backgroundColor: "rgba(255,255,255,0.9)" }}
          />
        </Box>
      </Box>
    );
  }
);

export const CCTVSystemPage: React.FC = () => {
  // ========== –°–û–°–¢–û–Ø–ù–ò–Ø ==========
  const [chartData, setChartData] = useState<CCTVDataPoint[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdate, setLastUpdate] = useState<string>("");
  const [currentTab, setCurrentTab] = useState(0);
  const [selectedNode, setSelectedNode] = useState<string>("");
  const [pollingActive, setPollingActive] = useState<boolean>(true);
  const [selectedEquipmentType, setSelectedEquipmentType] = useState("all");

  const [devices, setDevices] = useState<CCTVDevice[]>([]);
  const [filteredDevices, setFilteredDevices] = useState<CCTVDevice[]>([]);
  const [wsConnected, setWsConnected] = useState<boolean>(false);

  const [schemePage, setSchemePage] = useState<number>(1);
  const [schemeRowsPerPage] = useState<number>(9);
  const [equipmentPage, setEquipmentPage] = useState<number>(1);
  const [equipmentRowsPerPage, setEquipmentRowsPerPage] = useState<number>(10);
  const [equipmentTotalCount, setEquipmentTotalCount] = useState<number>(0);
  
  const [maintenanceTasks, setMaintenanceTasks] = useState<CCTVMaintenanceTask[]>([]);
  const [allTasks, setAllTasks] = useState<CCTVMaintenanceTask[]>([]);
  const [tasksLoading, setTasksLoading] = useState<boolean>(true);
  const [tasksPage, setTasksPage] = useState<number>(1);
  const [tasksRowsPerPage, setTasksRowsPerPage] = useState<number>(10);

  const { setAlarm, loading: alarmLoading } = useAlert();
  
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: "",
    severity: "info" as "success" | "info" | "warning" | "error",
  });

  // ========== –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò ==========
  const getStatusColor = (status: string) => {
    switch (status.toLowerCase()) {
      case "normal": case "–Ω–æ—Ä–º–∞": case "–∞–∫—Ç–∏–≤–µ–Ω": return "success";
      case "warning": case "–≤–Ω–∏–º–∞–Ω–∏–µ": case "–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ": return "warning";
      case "critical": case "–∫—Ä–∏—Ç–∏—á–Ω–æ": case "–æ—à–∏–±–∫–∞": return "error";
      default: return "default";
    }
  };

  const getStatusIcon = (status: string) => {
    switch (status.toLowerCase()) {
      case "normal": case "–Ω–æ—Ä–º–∞": case "–∞–∫—Ç–∏–≤–µ–Ω": return <CheckCircle fontSize="small" />;
      case "warning": case "–≤–Ω–∏–º–∞–Ω–∏–µ": case "–ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ": return <WarningIcon fontSize="small" />;
      case "critical": case "–∫—Ä–∏—Ç–∏—á–Ω–æ": case "–æ—à–∏–±–∫–∞": return <ErrorIcon fontSize="small" />;
      default: return <CheckCircle fontSize="small" />;
    }
  };

  const getDeviceIcon = (type: string) => {
    switch (type.toLowerCase()) {
      case "camera": case "–∫–∞–º–µ—Ä–∞": return <Camera />;
      case "recorder": case "—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä": case "rg": return <Storage />;
      case "server": case "—Å–µ—Ä–≤–µ—Ä": case "sr": return <Computer />;
      case "switch": case "–∫–æ–º–º—É—Ç–∞—Ç–æ—Ä": return <Lan />;
      case "nvr": case "nvr-—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä": return <Router />;
      case "scanner": case "—Å–∫–∞–Ω–µ—Ä": case "sc": return <Videocam />;
      default: return <Videocam />;
    }
  };

  const formatDeviceValue = (device: CCTVDevice): string => {
    if (device.currentValue !== undefined) {
      let unit = "–µ–¥.";
      if (device.param?.startsWith('cam')) unit = 'fps';
      if (device.param?.startsWith('rg')) unit = '–∫–ë/—Å';
      if (device.param?.startsWith('sc')) unit = '%';
      if (device.param?.startsWith('sr')) unit = '–µ–¥.';
      return `${device.currentValue.toFixed(2)} ${unit}`;
    }
    return device.value || "–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö";
  };

  const mapDeviceType = (deviceType: string, param?: string): string => {
    if (!deviceType) {
      // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—É
      if (param?.startsWith('cam')) return "camera";
      if (param?.startsWith('rg')) return "recorder";
      if (param?.startsWith('sc')) return "scanner";
      if (param?.startsWith('sr')) return "server";
      return "camera";
    }

    const typeLower = deviceType.toLowerCase();

    if (typeLower.includes("–∫–∞–º–µ—Ä–∞") || typeLower.includes("camera") || typeLower.includes("cam")) {
      return "camera";
    }
    if (typeLower.includes("—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä") || typeLower.includes("recorder") || typeLower.includes("rg")) {
      return "recorder";
    }
    if (typeLower.includes("—Å–µ—Ä–≤–µ—Ä") || typeLower.includes("server") || typeLower.includes("sr")) {
      return "server";
    }
    if (typeLower.includes("—Å–∫–∞–Ω–µ—Ä") || typeLower.includes("scanner") || typeLower.includes("sc")) {
      return "scanner";
    }
    if (typeLower.includes("–∫–æ–º–º—É—Ç–∞—Ç–æ—Ä") || typeLower.includes("switch") || typeLower.includes("sw")) {
      return "switch";
    }
    return "camera";
  };

  // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –ü–û–õ–£–ß–ï–ù–ò–Ø –†–ï–ê–õ–¨–ù–´–• –î–ê–ù–ù–´–• ==========
  const fetchFromGetDevicesHTF = useCallback(async (paramPrefix: string): Promise<CCTVDataPoint[]> => {
    try {
      console.log('üîç fetchFromGetDevicesHTF –¥–ª—è –ø—Ä–µ—Ñ–∏–∫—Å–∞:', paramPrefix);
      
      const functionsBase = FUNCTIONS;
      if (!functionsBase) {
        console.error('‚ùå FUNCTIONS –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤ env');
        return [];
      }
      
      // –ü–ï–†–ï–î–ê–ï–ú –ü–†–ï–§–ò–ö–° (–Ω–∞–ø—Ä–∏–º–µ—Ä "cam"), –∞ –Ω–µ –ø–æ–ª–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä ("cam1")
      const requestData = [{ param: paramPrefix }];
      
      console.log('üì§ –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å —Å –¥–∞–Ω–Ω—ã–º–∏:', JSON.stringify(requestData));
      
      const response = await apiClient.post<HTFResponseItem[]>(
        'getDevicesHTF',
        requestData,
        { 
          baseURL: functionsBase,
          headers: {
            'Content-Type': 'application/json'
          }
        }
      );
      
      console.log('üì• –û—Ç–≤–µ—Ç getDevicesHTF:', {
        —Ç–∏–ø: Array.isArray(response) ? '–º–∞—Å—Å–∏–≤' : typeof response,
        –¥–ª–∏–Ω–∞: Array.isArray(response) ? response.length : 'N/A',
      });
      
      if (response && Array.isArray(response) && response.length > 0) {
        const historicalData: CCTVDataPoint[] = [];
        
        response.forEach((item: HTFResponseItem) => {
          if (item.vValue && Array.isArray(item.vValue) && item.vValue[0]) {
            const values = item.vValue[0];
            
            // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Å –∑–∞–¥–∞–Ω–Ω—ã–º –ø—Ä–µ—Ñ–∏–∫—Å–æ–º
            Object.keys(values).forEach(key => {
              if (key.startsWith(paramPrefix) && key !== 'volumeDate' && key !== 'id') {
                const valueStr = String(values[key]).replace(',', '.');
                const value = parseFloat(valueStr);
                
                if (!isNaN(value)) {
                  historicalData.push({
                    timestamp: item.vUpdateTime,
                    value: value,
                    node: key,
                    param: key
                  });
                }
              }
            });
          }
        });
        
        console.log(`üìà –ù–∞–π–¥–µ–Ω–æ ${historicalData.length} —Ç–æ—á–µ–∫ –¥–ª—è –ø—Ä–µ—Ñ–∏–∫—Å–∞ ${paramPrefix}`);
        return historicalData;
      }
      
      return [];
      
    } catch (error: any) {
      console.error('‚ùå –û—à–∏–±–∫–∞ getDevicesHTF:', error.message);
      return [];
    }
  }, []);

  // ========== –§–£–ù–ö–¶–ò–ò –î–õ–Ø –û–ë–°–õ–£–ñ–ò–í–ê–ù–ò–Ø ==========
  const getTaskStatusInfo = (action: string) => {
    const actionLower = action.toLowerCase();
    
    if (actionLower.includes('–≤—ã–ø–æ–ª–Ω–µ–Ω–æ') || actionLower.includes('–∑–∞–≤–µ—Ä—à–µ–Ω–æ')) {
      return { label: '–í—ã–ø–æ–ª–Ω–µ–Ω–æ', color: 'success' as const };
    } else if (actionLower.includes('–∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ') || actionLower.includes('–ø–ª–∞–Ω')) {
      return { label: '–ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ', color: 'info' as const };
    } else if (actionLower.includes('–∑–∞–¥–µ—Ä–∂') || actionLower.includes('–æ—Ç–ª–æ–∂–µ–Ω')) {
      return { label: '–ó–∞–¥–µ—Ä–∂–∫–∞', color: 'warning' as const };
    } else if (actionLower.includes('–æ—Ç–º–µ–Ω') || actionLower.includes('–æ—Ç–∫–ª–æ–Ω–µ–Ω')) {
      return { label: '–û—Ç–º–µ–Ω–µ–Ω–æ', color: 'error' as const };
    } else if (actionLower.includes('–≤ —Ä–∞–±–æ—Ç–µ') || actionLower.includes('–≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è')) {
      return { label: '–í —Ä–∞–±–æ—Ç–µ', color: 'primary' as const };
    } else {
      return { label: action, color: 'default' as const };
    }
  };

  const fetchMaintenanceTasks = useCallback(async () => {
    try {
      setTasksLoading(true);
      
      const response = await apiClient.get<CCTVMaintenanceTask[]>('tblTasks');
      
      if (response && Array.isArray(response)) {
        const cctvTasks = response.filter(task => {
          const taskType = (task.type || '').toLowerCase();
          const taskDevice = (task.device || '').toLowerCase();
          
          return taskType.includes('–∫–∞–º–µ—Ä–∞') || 
                 taskType.includes('–≤–∏–¥–µ–æ') ||
                 taskType.includes('—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä') ||
                 taskType.includes('—Å–µ—Ä–≤–µ—Ä') ||
                 taskType.includes('nvr') ||
                 taskType.includes('dvr') ||
                 taskDevice.includes('–∫–∞–º–µ—Ä–∞') ||
                 taskDevice.includes('–≤–∏–¥–µ–æ') ||
                 taskDevice.includes('cctv') ||
                 taskDevice.includes('—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä');
        });
        
        setAllTasks(cctvTasks);
        setMaintenanceTasks(cctvTasks);
      } else {
        setAllTasks([]);
        setMaintenanceTasks([]);
      }
    } catch (err: any) {
      console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∑–∞–¥–∞—á –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è CCTV:", err);
      setSnackbar({
        open: true,
        message: "–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è CCTV",
        severity: "error",
      });
      setAllTasks([]);
      setMaintenanceTasks([]);
    } finally {
      setTasksLoading(false);
    }
  }, []);

  // ========== –ó–ê–ì–†–£–ó–ö–ê –£–°–¢–†–û–ô–°–¢–í CCTV ==========
  const filterCCTVDevices = useCallback((deviceData: any[]): CCTVDevice[] => {
    return deviceData
      .filter((device: any) => {
        const group = (device.group || "").toLowerCase().trim();
        const param = (device.param || "").toLowerCase();
        const name = (device.name || "").toLowerCase();
        
        // –ò—â–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ video/cctv
        return group === "video" || 
               group === "cctv" ||
               param.startsWith("cam") ||
               param.startsWith("rg") ||
               param.startsWith("sc") ||
               param.startsWith("sr") ||
               name.includes("–∫–∞–º–µ—Ä–∞") ||
               name.includes("–≤–∏–¥–µ–æ") ||
               name.includes("cctv") ||
               name.includes("—Ä–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä");
      })
      .map((device: any, index: number): CCTVDevice => {
        const deviceType = mapDeviceType(device.type || device.description || device.name, device.param);

        let status: "normal" | "warning" | "critical" = "normal";
        if (device.status === "warning" || device.status === "–í–Ω–∏–º–∞–Ω–∏–µ") {
          status = "warning";
        } else if (device.status === "critical" || device.status === "–ö—Ä–∏—Ç–∏—á–Ω–æ") {
          status = "critical";
        }

        const deviceId = device.param || device.id || `cctv-${index}`;

        return {
          id: deviceId,
          name: device.name || `–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ ${deviceId}`,
          type: deviceType,
          status: status,
          value: "–ù/–î",
          group: device.group,
          deviceId: deviceId,
          deviceName: device.name,
          location: device.dislocation || "–ù–µ —É–∫–∞–∑–∞–Ω–æ",
          timestamp: device.timestamp || new Date().toISOString(),
          description: device.description,
          param: device.param,
          active: device.active,
          ipAddress: undefined,
          resolution: "1080p",
          fps: undefined,
          storageUsage: undefined,
          isOnline: device.active !== false,
          currentValue: undefined,
        };
      });
  }, []);

  const fetchCCTVDevices = useCallback(async () => {
    try {
      setLoading(true);

      const response = await apiClient.get("tblDevices");

      if (response && Array.isArray(response)) {
        const cctvDevices = filterCCTVDevices(response);
        console.log(`üìä –ù–∞–π–¥–µ–Ω–æ ${cctvDevices.length} —É—Å—Ç—Ä–æ–π—Å—Ç–≤ CCTV`);

        // –ó–ê–ì–†–£–ñ–ê–ï–ú –¢–ï–ö–£–©–ò–ï –ó–ù–ê–ß–ï–ù–ò–Ø –ò–ó tblValues
        try {
          const valuesResponse = await apiClient.get<TblValuesItem[]>('tblValues');
          if (valuesResponse && Array.isArray(valuesResponse)) {
            console.log(`üìà –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${valuesResponse.length} —Ç–µ–∫—É—â–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π`);
            
            const updatedDevices = cctvDevices.map(device => {
              if (device.param) {
                // –ò—â–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
                const deviceValue = valuesResponse.find((item: TblValuesItem) => 
                  item.param === device.param ||
                  item.name === device.param ||
                  item.id === device.param
                );
                
                if (deviceValue) {
                  const valueStr = String(deviceValue.value || deviceValue.data || deviceValue.val || '0');
                  const numericValue = parseFloat(valueStr.replace(',', '.'));
                  
                  if (!isNaN(numericValue)) {
                    let unit = "–µ–¥.";
                    if (device.param.startsWith('cam')) unit = 'fps';
                    if (device.param.startsWith('rg')) unit = '–∫–ë/—Å';
                    if (device.param.startsWith('sc')) unit = '%';
                    if (device.param.startsWith('sr')) unit = '–µ–¥.';
                    
                    return {
                      ...device,
                      value: `${numericValue.toFixed(2)} ${unit}`,
                      currentValue: numericValue, // –°–æ—Ö—Ä–∞–Ω—è–µ–º —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                      timestamp: deviceValue.timestamp || deviceValue.time || deviceValue.created_at || new Date().toISOString()
                    };
                  }
                } else {
                  console.log(`‚ö†Ô∏è –ù–µ –Ω–∞–π–¥–µ–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞: ${device.param}`);
                }
              }
              return device;
            });
            
            setDevices(updatedDevices);
            setFilteredDevices(updatedDevices);
            setEquipmentTotalCount(updatedDevices.length);
            
            // –ê–≤—Ç–æ–≤—ã–±–æ—Ä –ø–µ—Ä–≤–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            if (updatedDevices.length > 0 && !selectedNode) {
              const firstDevice = updatedDevices[0];
              setSelectedNode(firstDevice.id);
              if (firstDevice.param) {
                // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –¥–ª—è getDevicesHTF
                const prefix = firstDevice.param.replace(/\d+$/, '');
                await fetchHistoricalDataForDevice(firstDevice.id, prefix, firstDevice.param);
              }
            }
          } else {
            console.warn('‚ö†Ô∏è tblValues –≤–µ—Ä–Ω—É–ª –Ω–µ –º–∞—Å—Å–∏–≤');
            setDevices(cctvDevices);
            setFilteredDevices(cctvDevices);
            setEquipmentTotalCount(cctvDevices.length);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∑–Ω–∞—á–µ–Ω–∏–π:', error);
          setDevices(cctvDevices);
          setFilteredDevices(cctvDevices);
          setEquipmentTotalCount(cctvDevices.length);
        }

        setError(null);
      }
    } catch (err: any) {
      console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ CCTV:", err);
      setSnackbar({
        open: true,
        message: `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ CCTV: ${err.message}`,
        severity: 'error'
      });
    } finally {
      setLoading(false);
    }
  }, [selectedNode, filterCCTVDevices]);

  // ========== –û–ë–ù–û–í–õ–ï–ù–ò–ï –î–ê–ù–ù–´–• –ì–†–ê–§–ò–ö–ê ==========
  const fetchHistoricalDataForDevice = useCallback(async (deviceId: string, paramPrefix: string, specificParam?: string) => {
    console.log(`üîÑ –ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ ${deviceId}, –ø—Ä–µ—Ñ–∏–∫—Å: ${paramPrefix}`);
    
    try {
      setRefreshing(true);
      
      // –ü–æ–ª—É—á–∞–µ–º –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –ø–æ –ø—Ä–µ—Ñ–∏–∫—Å—É
      const historicalData = await fetchFromGetDevicesHTF(paramPrefix);
      
      if (historicalData.length === 0) {
        console.error('‚ùå –ù–µ—Ç –∏—Å—Ç–æ—Ä–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è');
        setSnackbar({
          open: true,
          message: `–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–µ—Ñ–∏–∫—Å–∞ ${paramPrefix}`,
          severity: 'warning'
        });
        return;
      }
      
      // –ï—Å–ª–∏ —É–∫–∞–∑–∞–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä, —Ñ–∏–ª—å—Ç—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–µ–≥–æ
      let filteredData = historicalData;
      if (specificParam) {
        filteredData = historicalData.filter(item => item.param === specificParam);
        console.log(`üìä –î–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ ${specificParam} –Ω–∞–π–¥–µ–Ω–æ ${filteredData.length} —Ç–æ—á–µ–∫`);
      }
      
      // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏
      filteredData.sort((a, b) => 
        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
      );
      
      setChartData(filteredData);
      console.log(`‚úÖ –ì—Ä–∞—Ñ–∏–∫ –æ–±–Ω–æ–≤–ª–µ–Ω: ${filteredData.length} —Ç–æ—á–µ–∫`);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
      if (filteredData.length > 0) {
        const latestValue = filteredData[filteredData.length - 1].value;
        
        setDevices(prev => prev.map(d => 
          d.id === deviceId ? { 
            ...d, 
            currentValue: latestValue,
            timestamp: filteredData[filteredData.length - 1].timestamp
          } : d
        ));
      }
      
      setLastUpdate(new Date().toLocaleTimeString("ru-RU"));
      
    } catch (error: any) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≥—Ä–∞—Ñ–∏–∫–∞:', error.message);
      setSnackbar({
        open: true,
        message: `–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞: ${error.message}`,
        severity: 'error',
      });
    } finally {
      setRefreshing(false);
    }
  }, [fetchFromGetDevicesHTF]);

  // ========== WEB SOCKET ==========
  useEffect(() => {
    if (!WS_URL) {
      console.warn("WebSocket URL –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω");
      return;
    }

    const ws = new WebSocket(WS_URL);
    console.log("üîó –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ WebSocket –¥–ª—è CCTV:", WS_URL);

    ws.onopen = () => {
      console.log("‚úÖ WebSocket –ø–æ–¥–∫–ª—é—á–µ–Ω –¥–ª—è CCTV");
      setWsConnected(true);
      
      setSnackbar({
        open: true,
        message: "–†–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –ø–æ–¥–∫–ª—é—á–µ–Ω–æ –¥–ª—è CCTV",
        severity: "success",
      });
    };

    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);

        if (data.type === "UPDATE") {
          console.log("üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ WS");
          setLastUpdate(new Date().toLocaleTimeString("ru-RU"));
        }
      } catch (error) {
        console.error("‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ WS —Å–æ–æ–±—â–µ–Ω–∏—è:", error);
      }
    };

    ws.onerror = (error) => {
      console.error("‚ùå WebSocket –æ—à–∏–±–∫–∞:", error);
      setWsConnected(false);
      setSnackbar({
        open: true,
        message: "–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è WebSocket",
        severity: "error",
      });
    };

    ws.onclose = () => {
      console.log("üîå WebSocket –æ—Ç–∫–ª—é—á–µ–Ω");
      setWsConnected(false);
    };

    return () => {
      ws.close();
    };
  }, []);

  // ========== –ê–í–¢–û–û–ë–ù–û–í–õ–ï–ù–ò–ï –ì–†–ê–§–ò–ö–ê (10 —Å–µ–∫—É–Ω–¥) ==========
  useEffect(() => {
    if (!pollingActive || !selectedNode) return;
    
    const intervalId = setInterval(() => {
      console.log('üîÑ –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö CCTV');
      const selectedDevice = devices.find(d => d.id === selectedNode);
      if (selectedDevice?.param) {
        const prefix = selectedDevice.param.replace(/\d+$/, '');
        fetchHistoricalDataForDevice(selectedNode, prefix, selectedDevice.param);
      }
    }, 10000);
    
    return () => clearInterval(intervalId);
  }, [pollingActive, selectedNode, devices, fetchHistoricalDataForDevice]);

  // ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò ==========
  const handleManualRefresh = useCallback(() => {
    fetchCCTVDevices();
    const selectedDevice = devices.find(d => d.id === selectedNode);
    if (selectedDevice?.param) {
      const prefix = selectedDevice.param.replace(/\d+$/, '');
      fetchHistoricalDataForDevice(selectedNode, prefix, selectedDevice.param);
    }
    fetchMaintenanceTasks();
  }, [fetchCCTVDevices, selectedNode, devices, fetchHistoricalDataForDevice, fetchMaintenanceTasks]);

  const handleNodeClick = useCallback(async (nodeId: string) => {
    setSelectedNode(nodeId);
    
    const device = devices.find(d => d.id === nodeId);
    if (device?.param) {
      const prefix = device.param.replace(/\d+$/, '');
      await fetchHistoricalDataForDevice(nodeId, prefix, device.param);
    }
  }, [devices, fetchHistoricalDataForDevice]);

  const handleAlarmClick = useCallback(async () => {
    const device = devices.find((d) => d.id === selectedNode);
    if (!device) {
      setSnackbar({
        open: true,
        message: "–£—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ",
        severity: "warning",
      });
      return;
    }

    try {
      const currentUser = localStorage.getItem('userName') || 'admin';
      
      await setAlarm({
        parameter: device.param || device.id,
        value: device.value || '–ù/–î',
        user: currentUser
      });

      setSnackbar({
        open: true,
        message: `–°–∏–≥–Ω–∞–ª —Ç—Ä–µ–≤–æ–≥–∏ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –¥–ª—è ${device.name}`,
        severity: "success",
      });
    } catch (err: any) {
      console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ —Å–∏–≥–Ω–∞–ª–∞ —Ç—Ä–µ–≤–æ–≥–∏:', err);
      setSnackbar({
        open: true,
        message: `–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–∏–≥–Ω–∞–ª–∞ —Ç—Ä–µ–≤–æ–≥–∏: ${err.message || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}`,
        severity: "error",
      });
    }
  }, [devices, selectedNode, setAlarm]);

  const renderAlarmButton = () => {
    if (!selectedNode) return null;

    return (
      <Tooltip title="–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–∏–≥–Ω–∞–ª —Ç—Ä–µ–≤–æ–≥–∏">
        <Fab
          color="error"
          size="small"
          onClick={handleAlarmClick}
          disabled={alarmLoading}
          sx={{ 
            boxShadow: 2,
            position: 'relative'
          }}
        >
          {alarmLoading ? (
            <CircularProgress size={20} color="inherit" />
          ) : (
            <WarningIcon />
          )}
        </Fab>
      </Tooltip>
    );
  };

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setCurrentTab(newValue);
  };

  const handleCloseSnackbar = () => {
    setSnackbar((prev) => ({ ...prev, open: false }));
  };

  const handleEquipmentTypeChange = (event: SelectChangeEvent) => {
    const type = event.target.value;
    setSelectedEquipmentType(type);
    
    if (type === "all") {
      setFilteredDevices(devices);
      setEquipmentTotalCount(devices.length);
    } else {
      const filtered = devices.filter(device => 
        device.type.toLowerCase() === type.toLowerCase()
      );
      setFilteredDevices(filtered);
      setEquipmentTotalCount(filtered.length);
    }
    setEquipmentPage(1);
    setSchemePage(1);
  };

  // ========== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ü–ê–ì–ò–ù–ê–¶–ò–ò ==========
  const handleSchemePageChange = (newPage: number) => {
    setSchemePage(newPage);
  };

  const handleEquipmentPageChange = (newPage: number) => {
    setEquipmentPage(newPage);
  };

  const handleEquipmentRowsPerPageChange = (newRowsPerPage: number) => {
    setEquipmentRowsPerPage(newRowsPerPage);
    setEquipmentPage(1);
  };

  const handleTasksPageChange = (newPage: number) => {
    setTasksPage(newPage);
  };

  const handleTasksRowsPerPageChange = (newRowsPerPage: number) => {
    setTasksRowsPerPage(newRowsPerPage);
    setTasksPage(1);
  };

  // ========== –í–´–ß–ò–°–õ–Ø–ï–ú–´–ï –ó–ù–ê–ß–ï–ù–ò–Ø ==========
  const schemeTotalCount = filteredDevices.length;
  const schemeTotalPages = Math.ceil(schemeTotalCount / schemeRowsPerPage);
  const paginatedDevices = useMemo(() => {
    const startIndex = (schemePage - 1) * schemeRowsPerPage;
    const endIndex = startIndex + schemeRowsPerPage;
    return filteredDevices.slice(startIndex, endIndex);
  }, [filteredDevices, schemePage, schemeRowsPerPage]);

  const equipmentPageDevices = useMemo(() => {
    const startIndex = (equipmentPage - 1) * equipmentRowsPerPage;
    const endIndex = startIndex + equipmentRowsPerPage;
    return filteredDevices.slice(startIndex, endIndex);
  }, [filteredDevices, equipmentPage, equipmentRowsPerPage]);

  const paginatedTasks = useMemo(() => {
    const startIndex = (tasksPage - 1) * tasksRowsPerPage;
    const endIndex = startIndex + tasksRowsPerPage;
    return allTasks.slice(startIndex, endIndex);
  }, [allTasks, tasksPage, tasksRowsPerPage]);

  const tasksTotalCount = allTasks.length;
  const selectedDevice = useMemo(() => {
    return devices.find((d) => d.id === selectedNode) || filteredDevices[0];
  }, [devices, selectedNode, filteredDevices]);

  // ========== –≠–§–§–ï–ö–¢–´ ==========
  useEffect(() => {
    fetchCCTVDevices();
    fetchMaintenanceTasks();
  }, [fetchCCTVDevices, fetchMaintenanceTasks]);

  // ========== –†–ï–ù–î–ï–† ==========
  return (
    <Box sx={{ p: 3, height: "100vh", display: "flex", flexDirection: "column", gap: 3 }}>
      {/* –®–∞–ø–∫–∞ */}
      <Paper sx={{ p: 3, borderRadius: 2 }}>
        <Box sx={{ display: "flex", alignItems: "center", justifyContent: "space-between", mb: 2 }}>
          <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
            <Videocam sx={{ fontSize: 40, color: "primary.main" }} />
            <Box>
              <Typography variant="h4">–°–∏—Å—Ç–µ–º–∞ –≤–∏–¥–µ–æ–Ω–∞–±–ª—é–¥–µ–Ω–∏—è</Typography>
              <Box sx={{ display: "flex", alignItems: "center", gap: 2, flexWrap: "wrap", mt: 1 }}>
                {wsConnected ? (
                  <Chip
                    icon={<CheckCircle fontSize="small" />}
                    label="WS –ø–æ–¥–∫–ª—é—á–µ–Ω"
                    color="success"
                    size="small"
                    variant="outlined"
                  />
                ) : (
                  <Chip
                    icon={<WarningIcon fontSize="small" />}
                    label="WS –æ—Ç–∫–ª—é—á–µ–Ω"
                    color="warning"
                    size="small"
                    variant="outlined"
                  />
                )}
                <Chip
                  label={`${devices.length} —É—Å—Ç—Ä–æ–π—Å—Ç–≤`}
                  color="info"
                  size="small"
                  variant="outlined"
                />
                <Typography variant="caption" color="text.secondary">
                  –ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {pollingActive ? '–≤–∫–ª (10 —Å–µ–∫)' : '–≤—ã–∫–ª'}
                </Typography>
              </Box>
            </Box>
          </Box>

          <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
            <Typography variant="body2" color="text.secondary">
              –ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ: {lastUpdate}
            </Typography>
          </Box>

          <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
            <FormControlLabel
              control={
                <Switch
                  checked={pollingActive}
                  onChange={(e) => setPollingActive(e.target.checked)}
                  size="small"
                />
              }
              label="–ê–≤—Ç–æ–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ"
              labelPlacement="start"
              sx={{ m: 0 }}
            />

            <Tooltip title="–û–±–Ω–æ–≤–∏—Ç—å –≤—Å–µ –¥–∞–Ω–Ω—ã–µ">
              <IconButton
                onClick={handleManualRefresh}
                disabled={refreshing || loading}
              >
                <Refresh />
              </IconButton>
            </Tooltip>
          </Box>
        </Box>

        {error && (
          <Alert severity="error" sx={{ mt: 2 }}>
            {error}
          </Alert>
        )}
      </Paper>

      {/* –¢–∞–±—ã */}
      <Paper>
        <Tabs value={currentTab} onChange={handleTabChange} variant="fullWidth">
          <Tab icon={<Schema />} iconPosition="start" label="–ú–Ω–µ–º–æ—Å—Ö–µ–º–∞" />
          <Tab icon={<Build />} iconPosition="start" label="–û–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ" />
          <Tab icon={<Schedule />} iconPosition="start" label="–†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è" />
        </Tabs>
      </Paper>

      {/* –ö–æ–Ω—Ç–µ–Ω—Ç —Ç–∞–±–æ–≤ */}
      <Box sx={{ flex: 1, overflow: "hidden" }}>
        {/* –í–∫–ª–∞–¥–∫–∞ –ú–Ω–µ–º–æ—Å—Ö–µ–º–∞ */}
        <TabPanel value={currentTab} index={0}>
          <Grid container spacing={3} sx={{ height: "100%", minHeight: "600px" }}>
            {/* –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –°—Ö–µ–º–∞ */}
            <Grid item xs={12} md={6}>
              <Paper sx={{ height: "100%", p: 3, display: "flex", flexDirection: "column" }}>
                <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 3 }}>
                  <Typography variant="h6" gutterBottom>
                    –°—Ö–µ–º–∞ —Å–∏—Å—Ç–µ–º—ã –≤–∏–¥–µ–æ–Ω–∞–±–ª—é–¥–µ–Ω–∏—è
                  </Typography>
                  {renderAlarmButton()}
                </Box>

                {/* –°—Ö–µ–º–∞ 3x3 —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π */}
                <Box sx={{ flex: 1, position: "relative", bgcolor: "#f8f9fa", borderRadius: 2, overflow: "auto", mb: 3, p: 2, display: "flex", flexDirection: "column" }}>
                  {loading ? (
                    <Box sx={{ display: "flex", justifyContent: "center", alignItems: "center", height: "100%" }}>
                      <CircularProgress />
                    </Box>
                  ) : filteredDevices.length === 0 ? (
                    <Box sx={{ display: "flex", flexDirection: "column", justifyContent: "center", alignItems: "center", height: "100%", gap: 2 }}>
                      <Typography variant="body1" color="text.secondary">
                        –ù–µ—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤ CCTV –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                      </Typography>
                      <Button variant="outlined" startIcon={<Refresh />} onClick={handleManualRefresh}>
                        –û–±–Ω–æ–≤–∏—Ç—å
                      </Button>
                    </Box>
                  ) : (
                    <>
                      <Box sx={{ display: "grid", gridTemplateColumns: "repeat(3, 1fr)", gap: 2, flex: 1, mb: 2 }}>
                        {paginatedDevices.map((device) => (
                          <Card
                            key={device.id}
                            onClick={() => handleNodeClick(device.id)}
                            sx={{
                              cursor: "pointer",
                              transition: "all 0.3s",
                              border: selectedNode === device.id ? "2px solid #1976d2" : "1px solid #e0e0e0",
                              backgroundColor: selectedNode === device.id ? "primary.50" : "white",
                              position: "relative",
                              "&:hover": { transform: "translateY(-2px)", boxShadow: 4 },
                              minHeight: "120px",
                            }}
                          >
                            <CardContent sx={{ p: 2, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", height: "100%" }}>
                              <Avatar sx={{ bgcolor: `${getStatusColor(device.status)}.light`, color: `${getStatusColor(device.status)}.dark`, mb: 1, width: 40, height: 40 }}>
                                {getDeviceIcon(device.type)}
                              </Avatar>
                              <Typography variant="caption" fontWeight="bold" align="center" noWrap>
                                {device.name}
                              </Typography>
                              <Typography variant="caption" color="text.secondary" align="center">
                                {device.param || device.id}
                              </Typography>
                              <Chip size="small" label={device.status === "normal" ? "–ù–æ—Ä–º–∞" : device.status === "warning" ? "–í–Ω–∏–º–∞–Ω–∏–µ" : "–ö—Ä–∏—Ç–∏—á–Ω–æ"} color={getStatusColor(device.status)} sx={{ mt: 1 }} />
                            </CardContent>
                          </Card>
                        ))}
                      </Box>

                      {/* –ü–∞–≥–∏–Ω–∞—Ü–∏—è —Å—Ö–µ–º—ã */}
                      {schemeTotalCount > schemeRowsPerPage && (
                        <Box sx={{ mt: 'auto', pt: 2, borderTop: '1px solid #e0e0e0' }}>
                          <ReportPagination
                            page={schemePage}
                            rowsPerPage={schemeRowsPerPage}
                            totalRows={schemeTotalCount}
                            onPageChange={handleSchemePageChange}
                            onRowsPerPageChange={() => {}}
                            disabled={loading}
                          />
                        </Box>
                      )}
                    </>
                  )}
                </Box>

                {/* –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ */}
                {selectedDevice && (
                  <Paper sx={{ p: 2, bgcolor: "grey.50" }}>
                    <Typography variant="subtitle2" gutterBottom>
                      –í—ã–±—Ä–∞–Ω–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ:
                    </Typography>
                    <Box sx={{ display: "flex", alignItems: "center", gap: 2 }}>
                      <Avatar sx={{ bgcolor: `${getStatusColor(selectedDevice.status)}.light`, color: `${getStatusColor(selectedDevice.status)}.dark` }}>
                        {getDeviceIcon(selectedDevice.type)}
                      </Avatar>
                      <Box>
                        <Typography variant="body1" fontWeight="medium">
                          {selectedDevice.name}
                        </Typography>
                        <Typography variant="body2" color="text.secondary">
                          ID: {selectedDevice.param || selectedDevice.id} ‚Ä¢ –¢–∏–ø: {selectedDevice.type}
                        </Typography>
                        <Typography variant="body2" color="primary" sx={{ mt: 0.5 }}>
                          –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {formatDeviceValue(selectedDevice)}
                        </Typography>
                      </Box>
                    </Box>
                  </Paper>
                )}
              </Paper>
            </Grid>

            {/* –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞: –ì—Ä–∞—Ñ–∏–∫ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è */}
            <Grid item xs={12} md={6}>
              <Grid container spacing={3} sx={{ height: "100%" }}>
                {/* –ì—Ä–∞—Ñ–∏–∫ */}
                <Grid item xs={12}>
                  <Card sx={{ height: "100%", display: "flex", flexDirection: "column" }}>
                    <CardHeader
                      title={
                        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                          <ShowChart color="primary" />
                          <Typography variant="h6">
                            {selectedDevice?.name || "–í–∏–¥–µ–æ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"} - –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥
                          </Typography>
                          {refreshing && <CircularProgress size={20} />}
                        </Box>
                      }
                      subheader={
                        <Box>
                          <Typography variant="caption">
                            –û–±–Ω–æ–≤–ª–µ–Ω–æ: {lastUpdate}
                          </Typography>
                          {chartData.length > 0 && (
                            <Typography variant="caption" sx={{ display: 'block', color: 'text.secondary' }}>
                              –¢–æ—á–µ–∫: {chartData.length} ‚Ä¢ 
                              –û—Ç {chartData[0]?.timestamp?.substring(11, 19) || 'N/A'} –¥–æ {chartData[chartData.length - 1]?.timestamp?.substring(11, 19) || 'N/A'}
                            </Typography>
                          )}
                        </Box>
                      }
                      action={
                        <Box sx={{ display: 'flex', gap: 1 }}>
                          <Tooltip title="–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞">
                            <IconButton
                              onClick={async () => {
                                if (selectedDevice?.param) {
                                  const prefix = selectedDevice.param.replace(/\d+$/, '');
                                  console.log(`üß™ –¢–µ—Å—Ç —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞: ${selectedDevice.name} (${selectedDevice.param}), –ø—Ä–µ—Ñ–∏–∫—Å: ${prefix}`);
                                  const data = await fetchFromGetDevicesHTF(prefix);
                                  console.log(`üìä –ü–æ–ª—É—á–µ–Ω–æ ${data.length} —Ç–æ—á–µ–∫ –¥–∞–Ω–Ω—ã—Ö`);
                                }
                              }}
                              size="small"
                            >
                              <Visibility />
                            </IconButton>
                          </Tooltip>
                          <Tooltip title="–û–±–Ω–æ–≤–∏—Ç—å –≥—Ä–∞—Ñ–∏–∫">
                            <IconButton 
                              onClick={() => {
                                if (selectedDevice?.param) {
                                  const prefix = selectedDevice.param.replace(/\d+$/, '');
                                  fetchHistoricalDataForDevice(selectedNode, prefix, selectedDevice.param);
                                }
                              }} 
                              disabled={refreshing || !selectedDevice?.param}
                              size="small"
                            >
                              <Refresh />
                            </IconButton>
                          </Tooltip>
                        </Box>
                      }
                    />
                    <CardContent sx={{ flex: 1, p: 2 }}>
                      <Box sx={{ height: "250px", width: "100%" }}>
                        <CCTVChart
                          data={chartData}
                          title={selectedDevice ? `${selectedDevice.name} - –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å` : "–í–∏–¥–µ–æ–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"}
                          color="#1976d2"
                          unit={selectedDevice?.param?.startsWith('cam') ? 'fps' : 
                                selectedDevice?.param?.startsWith('sc') ? '%' : '–µ–¥.'}
                          isLoading={refreshing}
                        />
                      </Box>

                      <Box sx={{ mt: 2, display: "flex", justifyContent: "space-between" }}>
                        <Typography variant="caption" color="text.secondary">
                          –û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç—Å—è: {chartData.length > 50 ? 50 : chartData.length} –∏–∑ {chartData.length} —Ç–æ—á–µ–∫
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          {chartData.length > 0 &&
                            `–î–∏–∞–ø–∞–∑–æ–Ω: ${Math.min(...chartData.map(d => d.value)).toFixed(1)} - ${Math.max(...chartData.map(d => d.value)).toFixed(1)}`}
                        </Typography>
                      </Box>
                    </CardContent>
                  </Card>
                </Grid>

                {/* –î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è */}
                <Grid item xs={12}>
                  <Card sx={{ height: "100%" }}>
                    <CardHeader
                      title={
                        <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                          <Settings color="primary" />
                          <Typography variant="h6">
                            –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± —É—Å—Ç—Ä–æ–π—Å—Ç–≤–µ
                          </Typography>
                        </Box>
                      }
                    />
                    <CardContent>
                      {selectedDevice ? (
                        <Box>
                          <Box sx={{ display: "flex", alignItems: "center", gap: 2, mb: 3 }}>
                            <Avatar sx={{ bgcolor: `${getStatusColor(selectedDevice.status)}.light`, color: `${getStatusColor(selectedDevice.status)}.main`, width: 60, height: 60 }}>
                              {getDeviceIcon(selectedDevice.type)}
                            </Avatar>
                            <Box>
                              <Typography variant="h6">{selectedDevice.name}</Typography>
                              <Box sx={{ display: "flex", alignItems: "center", gap: 1, mt: 1 }}>
                                <Chip label={selectedDevice.status === "normal" ? "–ù–æ—Ä–º–∞" : selectedDevice.status === "warning" ? "–í–Ω–∏–º–∞–Ω–∏–µ" : "–ö—Ä–∏—Ç–∏—á–Ω–æ"} color={getStatusColor(selectedDevice.status)} size="small" />
                                <Chip label={selectedDevice.type} variant="outlined" size="small" />
                              </Box>
                            </Box>
                          </Box>

                          {selectedDevice.currentValue !== undefined && (
                            <Paper
                              sx={{
                                p: 2,
                                mb: 2,
                                bgcolor: "primary.light",
                                color: "primary.contrastText",
                              }}
                            >
                              <Typography variant="subtitle2">
                                –¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                              </Typography>
                              <Typography
                                variant="h4"
                                sx={{ fontWeight: "bold" }}
                              >
                                {selectedDevice.currentValue.toFixed(2)}
                                {selectedDevice.param?.startsWith('cam') ? 'fps' : 
                                 selectedDevice.param?.startsWith('sc') ? '%' : '–µ–¥.'}
                              </Typography>
                              <Typography variant="caption">
                                {selectedDevice.timestamp ? 
                                  new Date(selectedDevice.timestamp).toLocaleTimeString('ru-RU') : 
                                  'N/A'}
                              </Typography>
                            </Paper>
                          )}

                          <Grid container spacing={2} sx={{ mb: 3 }}>
                            <Grid item xs={6}>
                              <Typography variant="caption" color="text.secondary">–ü–∞—Ä–∞–º–µ—Ç—Ä</Typography>
                              <Typography variant="body2">{selectedDevice.param || "–ù/–î"}</Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="caption" color="text.secondary">–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ</Typography>
                              <Typography variant="body2" fontWeight="medium">{formatDeviceValue(selectedDevice)}</Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="caption" color="text.secondary">–ì—Ä—É–ø–ø–∞</Typography>
                              <Typography variant="body2">{selectedDevice.group || "–ù–µ —É–∫–∞–∑–∞–Ω–∞"}</Typography>
                            </Grid>
                            <Grid item xs={6}>
                              <Typography variant="caption" color="text.secondary">–°—Ç–∞—Ç—É—Å</Typography>
                              <Typography variant="body2">
                                {selectedDevice.status === "normal" ? "–ù–æ—Ä–º–∞" : 
                                 selectedDevice.status === "warning" ? "–í–Ω–∏–º–∞–Ω–∏–µ" : 
                                 "–ö—Ä–∏—Ç–∏—á–Ω–æ"}
                              </Typography>
                            </Grid>
                          </Grid>

                          <Box sx={{ display: "flex", gap: 1, justifyContent: "center" }}>
                            <Button 
                              size="small" 
                              startIcon={<History />} 
                              variant="outlined"
                              onClick={() => {
                                setSnackbar({
                                  open: true,
                                  message: `–û—Ç–∫—Ä—ã—Ç–∞ –∏—Å—Ç–æ—Ä–∏—è –¥–ª—è ${selectedDevice.name}`,
                                  severity: "info",
                                });
                              }}
                            >
                              –ò—Å—Ç–æ—Ä–∏—è
                            </Button>
                            <Button 
                              size="small" 
                              startIcon={<Assignment />} 
                              variant="outlined"
                              onClick={() => {
                                setSnackbar({
                                  open: true,
                                  message: `–°–æ–∑–¥–∞–Ω–∞ –∑–∞—è–≤–∫–∞ –¥–ª—è ${selectedDevice.name}`,
                                  severity: "info",
                                });
                              }}
                            >
                              –ó–∞—è–≤–∫–∞
                            </Button>
                          </Box>
                        </Box>
                      ) : (
                        <Box sx={{ display: "flex", flexDirection: "column", alignItems: "center", p: 3 }}>
                          <Typography variant="h6" color="text.secondary" gutterBottom>
                            –í—ã–±–µ—Ä–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –Ω–∞ —Å—Ö–µ–º–µ
                          </Typography>
                          <Typography variant="body2" color="text.secondary" align="center">
                            –ù–∞–∂–º–∏—Ç–µ –Ω–∞ –ª—é–±–æ–π —ç–ª–µ–º–µ–Ω—Ç —Å—Ö–µ–º—ã –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –∏ –≥—Ä–∞—Ñ–∏–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
                          </Typography>
                        </Box>
                      )}
                    </CardContent>
                  </Card>
                </Grid>
              </Grid>
            </Grid>
          </Grid>
        </TabPanel>

        {/* –í–∫–ª–∞–¥–∫–∞ –û–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ */}
        <TabPanel value={currentTab} index={1}>
          <Paper sx={{ p: 3 }}>
            <Box sx={{ display: "flex", justifyContent: "space-between", alignItems: "center", mb: 3 }}>
              <Typography variant="h5">
                –û–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã –≤–∏–¥–µ–æ–Ω–∞–±–ª—é–¥–µ–Ω–∏—è
              </Typography>
              <Box sx={{ display: "flex", gap: 2, alignItems: "center" }}>
                <FormControl size="small" sx={{ minWidth: 200 }}>
                  <InputLabel>–§–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–ø—É</InputLabel>
                  <Select value={selectedEquipmentType} label="–§–∏–ª—å—Ç—Ä –ø–æ —Ç–∏–ø—É" onChange={handleEquipmentTypeChange}>
                    <MenuItem value="all">–í—Å–µ —Ç–∏–ø—ã</MenuItem>
                    <MenuItem value="camera">–ö–∞–º–µ—Ä—ã</MenuItem>
                    <MenuItem value="recorder">–†–µ–≥–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã</MenuItem>
                    <MenuItem value="server">–°–µ—Ä–≤–µ—Ä—ã</MenuItem>
                    <MenuItem value="scanner">–°–∫–∞–Ω–µ—Ä—ã</MenuItem>
                  </Select>
                </FormControl>

                <Button variant="outlined" startIcon={<Refresh />} onClick={handleManualRefresh} disabled={loading}>
                  –û–±–Ω–æ–≤–∏—Ç—å
                </Button>
              </Box>
            </Box>

            <TableContainer component={Paper} variant="outlined">
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>–ü–∞—Ä–∞–º–µ—Ç—Ä</TableCell>
                    <TableCell>–ù–∞–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ</TableCell>
                    <TableCell>–¢–∏–ø</TableCell>
                    <TableCell>–°—Ç–∞—Ç—É—Å</TableCell>
                    <TableCell>–ó–Ω–∞—á–µ–Ω–∏–µ</TableCell>
                    <TableCell>–ì—Ä—É–ø–ø–∞</TableCell>
                    <TableCell>–ú–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ</TableCell>
                    <TableCell>–ü–æ—Å–ª–µ–¥–Ω–µ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ</TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {equipmentPageDevices.length > 0 ? (
                    equipmentPageDevices.map((device) => (
                      <TableRow 
                        key={device.id} 
                        hover 
                        sx={{ 
                          cursor: "pointer", 
                          "&:hover": { backgroundColor: "action.hover" },
                          backgroundColor: device.id === selectedNode ? "action.selected" : "inherit"
                        }} 
                        onClick={() => {
                          setSelectedNode(device.id);
                          setCurrentTab(0);
                        }}
                      >
                        <TableCell><Chip label={device.param || device.id} size="small" variant="outlined" /></TableCell>
                        <TableCell><Typography variant="body1" fontWeight="medium">{device.name}</Typography></TableCell>
                        <TableCell><Chip label={device.type} size="small" variant="outlined" /></TableCell>
                        <TableCell>
                          <Chip 
                            icon={getStatusIcon(device.status)} 
                            label={device.status === "normal" ? "–ù–æ—Ä–º–∞" : device.status === "warning" ? "–í–Ω–∏–º–∞–Ω–∏–µ" : "–ö—Ä–∏—Ç–∏—á–Ω–æ"} 
                            color={getStatusColor(device.status)} 
                            size="small" 
                          />
                        </TableCell>
                        <TableCell><Typography variant="body2">{formatDeviceValue(device)}</Typography></TableCell>
                        <TableCell>{device.group || "–ù–µ —É–∫–∞–∑–∞–Ω–∞"}</TableCell>
                        <TableCell>{device.location || "–ù–µ —É–∫–∞–∑–∞–Ω–æ"}</TableCell>
                        <TableCell>
                          {device.timestamp ? (
                            <Typography variant="caption">{new Date(device.timestamp).toLocaleString("ru-RU")}</Typography>
                          ) : (
                            "–ù/–î"
                          )}
                        </TableCell>
                      </TableRow>
                    ))
                  ) : (
                    <TableRow>
                      <TableCell colSpan={8} align="center" sx={{ py: 4 }}>
                        {loading ? (
                          <Box sx={{ display: "flex", alignItems: "center", justifyContent: "center", gap: 2 }}>
                            <CircularProgress size={24} />
                            <Typography>–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è...</Typography>
                          </Box>
                        ) : (
                          <Typography variant="body1" color="text.secondary">
                            –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è
                          </Typography>
                        )}
                      </TableCell>
                    </TableRow>
                  )}
                </TableBody>
              </Table>
            </TableContainer>

            {/* –ü–∞–≥–∏–Ω–∞—Ü–∏—è –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è */}
            {equipmentTotalCount > 0 && (
              <ReportPagination
                page={equipmentPage}
                rowsPerPage={equipmentRowsPerPage}
                totalRows={equipmentTotalCount}
                onPageChange={handleEquipmentPageChange}
                onRowsPerPageChange={handleEquipmentRowsPerPageChange}
                disabled={loading}
              />
            )}
          </Paper>
        </TabPanel>

        {/* –í–∫–ª–∞–¥–∫–∞ –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è */}
        <TabPanel value={currentTab} index={2}>
          <Paper sx={{ p: 3 }}>
            <Box sx={{
              display: "flex",
              justifyContent: "space-between",
              alignItems: "center",
              mb: 3,
            }}>
              <Typography variant="h5">
                –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è CCTV
                {tasksLoading && (
                  <CircularProgress size={20} sx={{ ml: 2 }} />
                )}
              </Typography>
              <Box sx={{ display: "flex", gap: 2, alignItems: "center" }}>
                <Button
                  variant="outlined"
                  startIcon={<Refresh />}
                  onClick={fetchMaintenanceTasks}
                  disabled={tasksLoading}
                >
                  –û–±–Ω–æ–≤–∏—Ç—å
                </Button>
              </Box>
            </Box>

            {allTasks.length === 0 ? (
              <Box sx={{
                display: "flex",
                flexDirection: "column",
                alignItems: "center",
                py: 6,
                textAlign: "center",
              }}>
                {tasksLoading ? (
                  <>
                    <CircularProgress size={40} sx={{ mb: 2 }} />
                    <Typography>–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è...</Typography>
                  </>
                ) : (
                  <>
                    <Typography variant="h6" color="text.secondary" gutterBottom>
                      –ù–µ—Ç –∑–∞–¥–∞—á –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      –ó–∞–¥–∞—á–∏ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è –¥–ª—è CCTV –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω—ã
                    </Typography>
                    <Button
                      variant="outlined"
                      startIcon={<Refresh />}
                      onClick={fetchMaintenanceTasks}
                      sx={{ mt: 2 }}
                    >
                      –ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞
                    </Button>
                  </>
                )}
              </Box>
            ) : (
              <>
                <TableContainer component={Paper} variant="outlined">
                  <Table>
                    <TableHead>
                      <TableRow>
                        <TableCell>ID</TableCell>
                        <TableCell>–û–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ</TableCell>
                        <TableCell>–¢–∏–ø –æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏—è</TableCell>
                        <TableCell>–¢–∏–ø —Ä–∞–±–æ—Ç—ã</TableCell>
                        <TableCell>–ü–ª–∞–Ω–∏—Ä—É–µ–º–∞—è –¥–∞—Ç–∞</TableCell>
                        <TableCell>–°—Ç–∞—Ç—É—Å</TableCell>
                        <TableCell>–û—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω—ã–π</TableCell>
                        <TableCell>–§–∞–∫—Ç. –¥–∞—Ç–∞</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {paginatedTasks.map((task) => {
                        const statusInfo = getTaskStatusInfo(task.action);
                        const plannedDate = new Date(task.taskDate);
                        const isOverdue = task.realDate === null && plannedDate < new Date();
                        
                        const relatedDevice = devices.find(d => 
                          d.name?.toLowerCase().includes(task.device.toLowerCase()) ||
                          task.device.toLowerCase().includes(d.name?.toLowerCase() || '')
                        );
                        
                        return (
                          <TableRow 
                            key={task.id} 
                            hover
                            sx={{
                              cursor: "pointer",
                              backgroundColor: isOverdue ? '#fff8e1' : 'inherit',
                              '&:hover': { backgroundColor: isOverdue ? '#fff5d6' : 'action.hover' },
                            }}
                          >
                            <TableCell>
                              <Chip
                                label={`#${task.id}`}
                                size="small"
                                variant="outlined"
                              />
                            </TableCell>
                            <TableCell>
                              <Box sx={{ display: "flex", alignItems: "center", gap: 1 }}>
                                {relatedDevice && (
                                  <Avatar
                                    sx={{
                                      width: 32,
                                      height: 32,
                                      bgcolor: `${getStatusColor(relatedDevice.status)}.light`,
                                    }}
                                  >
                                    {getDeviceIcon(relatedDevice.type)}
                                  </Avatar>
                                )}
                                <Typography variant="body1">
                                  {task.device}
                                </Typography>
                              </Box>
                            </TableCell>
                            <TableCell>
                              <Chip
                                label={task.type}
                                size="small"
                                variant="outlined"
                              />
                            </TableCell>
                            <TableCell>{task.task}</TableCell>
                            <TableCell>
                              <Box>
                                <Typography variant="body2">
                                  {plannedDate.toLocaleDateString("ru-RU")}
                                </Typography>
                                <Typography variant="caption" color="text.secondary">
                                  {plannedDate.toLocaleTimeString("ru-RU", {
                                    hour: '2-digit',
                                    minute: '2-digit'
                                  })}
                                </Typography>
                                {isOverdue && (
                                  <Typography variant="caption" color="error" sx={{ display: 'block', mt: 0.5 }}>
                                    –ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ
                                  </Typography>
                                )}
                              </Box>
                            </TableCell>
                            <TableCell>
                              <Chip
                                label={statusInfo.label}
                                color={statusInfo.color}
                                size="small"
                              />
                            </TableCell>
                            <TableCell>{task.user}</TableCell>
                            <TableCell>
                              {task.realDate ? (
                                <Typography variant="body2">
                                  {new Date(task.realDate).toLocaleDateString("ru-RU")}
                                </Typography>
                              ) : (
                                <Typography variant="body2" color="text.secondary" fontStyle="italic">
                                  –ù–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ
                                </Typography>
                              )}
                            </TableCell>
                          </TableRow>
                        );
                      })}
                    </TableBody>
                  </Table>
                </TableContainer>

                {/* –ü–∞–≥–∏–Ω–∞—Ü–∏—è –∑–∞–¥–∞—á */}
                {allTasks.length > 0 && (
                  <ReportPagination
                    page={tasksPage}
                    rowsPerPage={tasksRowsPerPage}
                    totalRows={tasksTotalCount}
                    onPageChange={handleTasksPageChange}
                    onRowsPerPageChange={handleTasksRowsPerPageChange}
                    disabled={tasksLoading}
                  />
                )}

                {/* –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ */}
                <Paper sx={{ p: 2, mt: 3, bgcolor: 'grey.50' }}>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6} md={3}>
                      <Box sx={{ textAlign: 'center' }}>
                        <Typography variant="h6" color="primary">
                          {tasksTotalCount}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          –í—Å–µ–≥–æ –∑–∞–¥–∞—á
                        </Typography>
                      </Box>
                    </Grid>
                    <Grid item xs={12} sm={6} md={3}>
                      <Box sx={{ textAlign: 'center' }}>
                        <Typography variant="h6" color="success.main">
                          {allTasks.filter(t => t.action.toLowerCase().includes('–≤—ã–ø–æ–ª–Ω–µ–Ω–æ')).length}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          –í—ã–ø–æ–ª–Ω–µ–Ω–æ
                        </Typography>
                      </Box>
                    </Grid>
                    <Grid item xs={12} sm={6} md={3}>
                      <Box sx={{ textAlign: 'center' }}>
                        <Typography variant="h6" color="info.main">
                          {allTasks.filter(t => t.action.toLowerCase().includes('–∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ')).length}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          –ó–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–æ
                        </Typography>
                      </Box>
                    </Grid>
                    <Grid item xs={12} sm={6} md={3}>
                      <Box sx={{ textAlign: 'center' }}>
                        <Typography variant="h6" color="warning.main">
                          {allTasks.filter(t => 
                            t.realDate === null && new Date(t.taskDate) < new Date()
                          ).length}
                        </Typography>
                        <Typography variant="caption" color="text.secondary">
                          –ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ
                        </Typography>
                      </Box>
                    </Grid>
                  </Grid>
                </Paper>
              </>
            )}
          </Paper>
        </TabPanel>
      </Box>

      {/* –°–Ω–µ–∫–±–∞—Ä */}
      <Snackbar 
        open={snackbar.open} 
        autoHideDuration={3000} 
        onClose={handleCloseSnackbar} 
        anchorOrigin={{ vertical: "bottom", horizontal: "right" }}
      >
        <Alert onClose={handleCloseSnackbar} severity={snackbar.severity}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};